#include "stm32f4xx.h"

/**
 * @brief  Setup the TIM5 to generate ms cycles,
 *         configured here with a 1MHz clk for the 32 bits counter
 *         so ms can go from 1 to 4294967
 * @param  ms : duration of the cycle
 * @retval None
 */
 void TIM5_set_periodic_event(uint32_t ms)
 {
	TIM_TypeDef  * tim = TIM5;
	/* choose the counter clock frequency. Here 1MHZ i chosen, so the counter
	 * will increment every 1us
	 */
	uint32_t ck_cnt_f = 1000000;

	/* enable tim peripheral clock */
	RCC->APB1ENR |= RCC_APB1ENR_TIM5EN;		/* activate TIM5 Clock */

	/* set prescaler to generate a clock with ck_cnt_f frequency,
	 * it is supposed here that ck_psc frequency = SystemCoreClock */
	tim->PSC = (SystemCoreClock / ck_cnt_f ) - 1;

	/*
	 * Note ARR define the cycle duration T, depend from the ck_cnt frequency
	 * and ck_cnt frequency depend on the timer clock and the prescaler value
	 * in s : T = (ARR+1) * ck_cnt_t
	 * 			= (ARR+1) / ck_cnt_f = (ARR+1) * (PSC+1) / SystemCoreClock
	 * 			= (ARR+1) / 1000000
	 * in ms : Tms = 1000 * (ARR+1) /1000000 = (ARR+1)/1000
	 * => ARR = 1000*Tms - 1
	 * note that the autoreload register is 32 bits for TIM5 */
	tim->ARR = 1000*ms - 1 ;
	/* update counter and prescaler : it clear prescaler and counter, to start
	 * with a full cycle. It will set the Update flag  (UIF), note that it can
	 * be avoided by setting the UDIS bit in CR1
	 * see TIM5_clear_periodic_event() */
	tim->EGR = TIM_EGR_UG;
	/* As an update has been generated by software,
	 * clear the bit in the status register, all flags can also be cleared */
	tim->SR &= ~ TIM_SR_UIF ;
	/* enable the counter (start counting) */
	tim->CR1 |= TIM_CR1_CEN ;
 }

/**
 * @brief pure polling method
 * @param  None
 * @retval None
 */
 void TIM5_wait_for_periodic_event(void)
 {
	 TIM_TypeDef  * tim = TIM5;
	 while ((tim->SR & TIM_SR_UIF) == 0){
		 // wait
	 }
	/* clear UIF and return */
	 TIM5->SR &= ~ TIM_SR_UIF ;
 }

 /**
  * @brief  clear counter to relanch a full cycle
  * @param  ms : duration of the cycle
  * @retval None
  */
  void TIM5_clear_periodic_event(void)
  {
	  /* to avoid generating a update event */
	  TIM5->CR1 |= TIM_CR1_UDIS ;
	  /* clear prescaler and counter */
	  TIM5->EGR = TIM_EGR_UG;
	  /* update enable to get the next overflow */
	  TIM5->CR1 &= ~ TIM_CR1_UDIS ;

  }

  /**
   * @brief  test if an update event has occurred
   * @param  None
   * @retval 1 if an update has occurred, otherwise 0
   */
  uint32_t TIM5_test_periodic_event(void)
  {
 	 if (TIM5->SR & TIM_SR_UIF){
 		/* clear UIF and return */
 		 TIM5->SR &= ~ TIM_SR_UIF ;
 		return 1;
 	 }
 	 else
 		 return 0;
  }

/*******************************************************************************
**************************  PWM for the LED    ********************************
*******************************************************************************
*/

/**
 * @brief  Setup the TIM2 (32 bits timer) to generate a PWM
 *         configured with 100kHz clock and 1000 possible value
 *         period set to 1000/100000 = 10ms (100Hz)
 * @param  None
 * @retval None
 */
void TIM2_Led_pwm_init(void)
{
	 TIM_TypeDef  * tim = TIM2;

	/* activate TIM2 Clock */
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

	/* prescaler value -> 100kHz */
	tim->PSC = (SystemCoreClock / 100000) - 1 ;
	/* autoreload register set for the counter to 10ms period*/
	tim->ARR = 1000 - 1 ;
	/* compare register 1 PWM value : CCR1/ARR*/
	tim->CCR1 = 0;	 // clear, PWM set to 0
	tim->CCMR1 = 0; // clear
	tim->CCMR1 = TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1PE; //PWM1
	tim->CCER = TIM_CCER_CC1E; /* output enable */
	tim->EGR = TIM_EGR_UG;	  // clear counter and prescaler (set the uif flag)
	tim->SR = 0;			  // Clear all interrupt flags in status register
	tim->CR1 |= TIM_CR1_CEN; // enable the counter
}

/**
 * @brief  set the value of CCR1 for PWM
 * @param  value for CCR1
 * @retval None
 */
void TIM2_Led_pwm_set(uint32_t value){
	TIM2->CCR1 = value;
}
/**
 * @brief  get the value of CCR1
 * @param  None
 * @retval value of CCR1
 */
uint32_t TIM2_Led_pwm_get()
{
	return TIM2->CCR1;
}

/*******************************************************************************
 ********************    pulse capture function for TIM4 ***********************
 *******************************************************************************
 */

#define TI2FP2TRIG 1		// 1 : use input PWM


/**
 * @brief  Initialize TIM4 to capture pulse duration, the code count also the
 * 			overflow for long pulse. 2 method can be used to get the pulse
 * 			duration :
 * 			1. use the PWM input mode by defining TI2FP2TRIG to 1, the counter
 * 			is cleared at each falling edge and the pulse duration is calculated
 * 			only from CCR1 + number of overflow
 * 			2. get the counter in CCR2 on falling edge and get the counter on
 * 			the rising edge in CCR1, substract the 2 values + overflow
 * @param  frequ : counter frequency (must be > SystemCoreClock/65536)
 *  		with 16MHz = 244, with 84MHz = 1280)
 * @retval None
 */
void TIM4_init(uint32_t frequ)
{
	TIM_TypeDef  * tim = TIM4;
	/* reset of the timer */
	RCC->APB1RSTR |= RCC_APB1RSTR_TIM4RST;
	RCC->APB1RSTR &= ~RCC_APB1RSTR_TIM4RST;
	RCC->APB1ENR |= RCC_APB1ENR_TIM4EN;		/* activate TIM4 Clock */

	tim->CR1 = 2<<TIM_CR1_CKD_Pos; // filter clock set to max and other bits cleared
	/* prescaler value set to get a frequ Hz clock */
	tim->PSC = (SystemCoreClock / frequ) - 1 ;
	/* auto reload register set to its maximum value */
	tim->ARR = 0xffff ;
	/* to enable change the in CCMR for CCxS bit the channel must be off */
	tim->CCER = 0;
	/* set TIM in input mode with TI2->CCR1 and TI2->CCR2*/
	/*IC2F set to 3=> 8 f_cnt clk samples (lots of rebound on the user button) */
	/* CC1S = 10 select TI2 for IC1 (select TI2 to trigger a capture in CCR1), Chanel configured as input.*/
    /* CC2S = 01 select TI2 for IC2 (select TI2 to trigger a capture in CCR2), Chanel configured as input.*/
	tim->CCMR1 = (3<<TIM_CCMR1_IC2F_Pos) | TIM_CCMR1_CC1S_1 | TIM_CCMR1_CC2S_0;
	/* select capture on falling edge of TI2 in CCR2 and rising edge in CCR1
	   CC1NP/CC1P = 00 and CC2NP/CC2P =01*/
	tim->CCER = TIM_CCER_CC2P ;

#if TI2FP2TRIG==1 // use falling edge as trigger for counter and PSC
	/* here the counter CNT is reseted on the rising edge on TI2FP2, here it is
	 * on the falling edge of TI2 (this mode is the 'input PWM')
	 * Configure the timer in reset mode by writing SMS=100 in TIMx_SMCR
	 * Select TI2 as the input source by writing TS=110 in TIMx_SMCR register.*/
	tim->SMCR &= ~(TIM_SMCR_TS_Msk | TIM_SMCR_SMS_Msk);
	tim->SMCR |= (0b110<<TIM_SMCR_TS_Pos) | (0b100<<TIM_SMCR_SMS_Pos);
#endif	//TI2FP2TRIG
	/* input capture enable */
	tim->CCER |= TIM_CCER_CC1E | TIM_CCER_CC2E;

	tim->EGR = TIM_EGR_UG;			/* clear counter and prescaler (set the uif flag) */
	tim->SR = 0;					/* Clear all flags in status register */
	tim->CR1 |= TIM_CR1_CEN ;		/* enable the counter */

}


/**
 * @brief  wait and compute the duration of a negative pulse.
 * 			it use CCR2 of TIM4 to capture the counter on a falling edge of
 * 			the signal and CCR1 to capture the counter on the rising edge
 * 			Overflow are taken into account.
 * 			the counter can be reseted at the beginning of the pulse (falling
 * 			edge)
 * @param  None
 * @retval None
 */
uint32_t TIM4_pulse_capture(void)
{
	TIM_TypeDef  * tim = TIM4;
	uint32_t pulse=0, overflow=0;
	uint32_t test1, test2, test3;

	/* reset flags and restart the counter to start to get an
	 * entire pulse (overflow must be counted !! )*/
	tim->EGR = TIM_EGR_UG;			/* clear counter and prescaler (set the uif flag) */
	tim->SR = 0;					/* Clear all flags in status register */

	/* wait for the capture of CNT in CCR1 (end of pulse) */
	while (!(tim->SR & TIM_SR_CC1IF)){
		/* test falling edge to reset overflow in case of overflow counting
		 * for long pulses*/
		if (tim->SR & TIM_SR_CC2IF){
			overflow=0;
			tim->SR &= ~(TIM_SR_UIF | TIM_SR_CC2IF);
		}

		/* test overflow and count them (for particularly long pulses) */
		if (tim->SR & TIM_SR_UIF){
			overflow += 1;
			tim->SR &= ~TIM_SR_UIF;
		}
	}

	/* calculate the pulse duration, take into account overflows */
	pulse = tim->CCR1;

#if TI2FP2TRIG==1		// use falling edge as trigger for counter
	/* in this case, CCR1 contain the duration, as CNT has been
	 * reseted at the falling edge of the signal, the number of overflow can be
	 * added
	 */
	pulse = (pulse)+overflow*0x10000;
#else					// the counter run free (no trigger)
	/* in this case, CCR2 contain the value corresponding to the start of the
	 * pulse and CCR1 the value corresponding to the end of the pulse
	 * the number of overflow can be added
	 */
	if (tim->CCR1 > tim->CCR2){
		pulse = (pulse - tim->CCR2)+overflow*0x10000; // overflow = 0x10000 ticks on 16 bits counter
	}
	else {
		if (overflow > 0){
			pulse += 0x10000 ; // add full period
			pulse -= tim->CCR2 ;
			pulse +=(overflow-1)*0x10000;
		}else
			pulse=0; /* CCR2 contain a value captured before the one in CCR1, negative pulse duration !! */
	}
#endif

	tim->SR=0; 						/*clear all flags */

	return pulse;
	//in ms : (pulse*tim->PSC)/(SystemCoreClock/1000); // (pulse*1000/frequ)

}



/********************* Periodic polling method *******************************/

/* pulse capture data that are shared between TIM4 function */
uint32_t TIM4_busy=0;
uint32_t TIM4_pulse=0;
uint32_t TIM4_overflow=0;

/**
 * @brief  polling method to test capture flags :
 * 			if a falling edge has occurred (TIM_SR_CC2IF), overflow is reseted
 * 			if an overflow (update event) has occured the overflow counter is
 * 				incremented (TIM4_overflow)
 * 			if a rising edge has occurred the capture is done
 * @param  none
 * @retval 1 if a capture has been done, 0 otherwise
 */
int32_t TIM4_wait_for_pulse_capture_poll(void)
{
	uint32_t pulse;
	TIM_TypeDef  * tim = TIM4;


	/* test for the falling edge that is the start of the negative pulse
	 * (capture of CNT in CCR2) */
	if (tim->SR & TIM_SR_CC2IF){
		/* reset overflow */
		TIM4_overflow=0;
		/* clear the flag capture */
		tim->SR &= ~TIM_SR_CC2IF;
#if TI2FP2TRIG==1 //(trigger on falling edge)
		/* clear update flag, as a trigger has been generated */
		tim->SR &= ~TIM_SR_UIF;
#endif
	}

	/* test overflow */
	if (tim->SR & TIM_SR_UIF){
		TIM4_overflow += 1;
		tim->SR &= ~TIM_SR_UIF;
	}
	/* test the capture of CNT in CCR1 (end of pulse) */
	if ((tim->SR & TIM_SR_CC1IF)){
		pulse = tim->CCR1;
#if TI2FP2TRIG==1
		/* in this case, CCR1 contain the duration, as CNT has been
		 * reseted at the falling edge of the signal, the number of overflow can
		 * be added
		 */
		pulse = pulse+TIM4_overflow*0x10000;
#else	//TI2FP2TRIG==0
		/* in this case, CCR2 contain the value corresponding to the start of
		 * the pulse and CCR1 the value corresponding to the end of the pulse
		 * the number of overflow can be added. Each overflow is a full counter
		 * with ARR = 0xFFFF, so 0x10000
		 */
		if (tim->CCR1 > tim->CCR2){
			pulse = (pulse - tim->CCR2)+TIM4_overflow*0x10000;
		}
		else {
			if (TIM4_overflow > 0){
				pulse += 0x10000 ; // add full period
				pulse -= tim->CCR2 ;
				pulse +=(TIM4_overflow-1)*0x10000;
			}else
				pulse=0; // should never reach
		}
#endif //TI2FP2TRIG

		/* set the global variable for the main application */
		TIM4_pulse = pulse; //(pulse*tim->PSC)/(SystemCoreClock/1000) in ms

		/* return 1 to signal that a capture has been done, note that
		 * no overrun error is checked
		 */
		return 1;
	}
	/* still waiting for the rising edge to end the capture */
	return 0;
}



/**
 * @brief  get the pulse in ticks
 * @param  none
 * @retval pulse duration in ticks
 */
uint32_t TIM4_get_pulse(void)
{
	return TIM4_pulse;
}

